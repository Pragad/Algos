2016/02/02

1. Locality based Mobile Search
    A. Problem:
        Search results for a user who is on the move should consider their location.

    B. How you solved it:
        OVERLAY:
        - Overlay is the individual items placed on the map
        - An overlay is an extra layer that sits on top of a View (the "host view")

        - Used vector of travel history to compute the FUTURE LOCATION of the user.
        - True vector is calculated by SUMMING UP all the previous vectors in our history.
        - Difference in LAT and LONG is divided by the difference in TIME to normalize the vectors w.r.t time
        - Find the FUTURE position by Defaulting TIME to 120 seconds from the current position.

        - GOOGLE PLACES API is used as our search engine.
        - IT provides the ability to perform a location based search using an ARBITRARY LOCATION
        - LIMITATION - 1000 user queries each day
        - WE give HTTP request as INPUT and get JSON as OUTPUT

        SAVE ENERGY:
        - Query repeatedly until we get a consistency in user's movement. After that exponentially backoff the querying
        - If change of direction happens then frequent querying


    C. Interesting Stuffs:
        - Using Passive Providers to get location instead of GPS
          http://stackoverflow.com/questions/6775257/android-location-providers-gps-or-network-provider

            There are 3 location providers in Android.
            1) GPS –> (GPS, AGPS):
               Name of the GPS location provider.
               This provider determines location using satellites.
               Depending on conditions, this provider may take a while to return a location fix.

            2) NETWORK –> (AGPS, CellID, WiFi MACID):
               Name of the network location provider.
               This provider determines location based on availability of cell tower and WiFi access points.
               Results are retrieved by means of a network lookup.

            3) PASSIVE –> (CellID, WiFi MACID):
               A special location provider for receiving locations without actually initiating a location fix.
               This provider can be used to passively receive location updates when other applications or services request them without actually requesting the locations yourself.
               This provider will return locations generated by other providers.
               This is what Android calls these location providers, however, the underlying technologies to make this stuff work is mapped to the specific set of hardware and telco provided capabilities (network service).

            The best way is to use the “network” or “passive” provider first, and then fallback on “gps”, and depending on the task, switch between providers. This covers all cases, and provides a lowest common denominator service (in the worst case) and great service (in the best case).

    D. Challenges and How you fixed it:
        - Signal LOSS and GPS fluctuation:
            - Found the average speed of the user and do an approximation
        - Drastic change of direction
            - Using vector summation and LOWERING the window of history

        - IMPOSSIBLE FUTURE LOCATION:
            - For the current speed future location showed in the ocean
            - Used REVERSE GEO-CODING to overcome it.

        - Impossible speed
            - Speed can go as high as 100mph which is impossible.

    E. Additional Notes:

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Filesystem
    A. Problem:
        - Given a 50K block create a hierarchial file system.
        - Create Files and Directories.
        - A file can have max of 504 bytes
        - A directory can have max of 10 entries inside it.

    B. How you solved it:
        - A linked list to track all available blocks

    C. Interesting Stuffs:

    D. Challenges and How you fixed it:

    E. Additional Notes:

In a 50k memory, designed directory and file structure in such a way that each file or directory takes 512 bytes(considered to be sector size).
User functionalities are to create or delete a directory, open, close, read, write or seek to the file content. 

1. To provide the user with no restriction in the size of file or directory (to deploy flat structure), I added dynamic creation of files and directories to the parent node when the size limit exceeds. In this way, the user will not be affected by the 512 bytes size restriction for a file or directory.

2. If the system's free block is not handled properly, there will be external fragmentation. Hence to solve that I created a linked list of blocks which is always in sorted order so that whenever there is file or directory deletion the blocks are inserted. Similarly when a file or directory is created, first available block from the linked list wil be used.

I would first test the project with basic test cases and verify if the core of my design works without any issues. As a second step, I will test with corner cases and add exception handling. Then, I will improve the performance of the project. I will also try to make my project reusable by splitting my code into smaller modules.

Later I will extend my project by adding nice to have features (like adding back or delete shortcut to above project). If I have more time I would concentrate on including support for GUI various fancy formats, different design and patterns which can improve user experience.

Flow:
-3. User can enter a Command on the CLI

-2. We get the Input command from the User and Parse it

-1. After parsing we figure out what the operation is


0. We maintained a LinkedList of unused blocks
    a. Every time a new entry gets inserted, top of stack is popped and used for storing it
    b. LinkedList just stores an Integer that represents which blocks are available

0b. Created an Array of 100 entries
    a. Each entry could be a file or a directory

1. Created 512 byte entry to represent a file
    a. A file entry will have 504 bytes to store data
    b. It has 4 byte to store previous pointer
    c. It has 4 bytes to store next pointer

2. Created another 512 byte entry to represent a directory
    a. It has 4 bytes for previous block
    b. It has 4 bytes for next block
    c. A pointer to first unused block
    d. A filler character (reserved)
    d. 31 directory entries
        i.e. At max, there can be 31 directories inside a directory
        - Holds type of sub directory
        - A directory name
        - Actual block where it is stored

3. For testing we limited the max number of entries inside a directory to 3.

4. As a directory can have 31 entries inside it,
    - Given a directory or file name you can go over the 31 entries and find the BLOCK
      NUMBER where the file/directory is stored

    - TODO: This can be improved by using a Hash Table

5. CREATE
    a. Check if the path already exists
        - Get the root block number
        - Using the block number, you can go to the corresponding entry in Array
        - Get the entry from the array. It will have a LIST OF ENTRIES (which could be 31)
        - Traverse through the list of entries and check if the "Name" exists
    b. So to create an entry you just get the next available block number and update it

6. DELETE
    a. Same as create. 
       - Find if path exists and free it
       - The directory can have sub directories.
       - So first free the sub / leaf directory and then delete the parent directory

7. OPEN
    a. Make sure the path exists
    b. This is allowed on a file
    c. Open the file in a specific mode that user is requesting
    d. Update the file with the mode that the user has opened
    e. Open modes can be "I", "O", "U"

8. CLOSE
    a. Clear the "I", "O", "U" flags set on the file

9. READ
    a. Will read only if the current pointer and user's amount of bytes is less than 504
    b. You have an array of 504 bytes holding the data
    c. You have a current offset stored
    d. Go to current offset use 'Divide by 504' AND 'Modulo 504' and go to the right place
    e. Read the necessary bytes

10. WRITE
    a. Same as READ, update the right pointers
    b. Write data at necessary bytes

11. SEEK
    a. Validity check to make sure we have enough bytes
    b. We go to the right offset and from that position display the amount of bytes
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. RFP Software Match
    A. Problem:
        - Allows user to upload RFP files for software the user is looking for. 
        - Searches the Civic Commons repository for applications mathcing to the user's RFP
        - Gets a list of mathcing software for the uploaded RFP

        - Log in through the user's Twitter id

    B. How you solved it:
        - 3 data stores
            - 1. To store the CIVIC Commons repository.
                - Periodically run the SCRAPER WIKI script and update the repository

            - 1. Apptype:  <ID, AppName, AppDescription, AppURL>

            - 2. RFPCollectionType: <ID, UserName, RFPName, RFPBody>

        - Lucene indexer is used to match the description of APPLICATIONS got from RFP with with description
          got from CIVIC commons repo.

    C. Interesting Stuffs:

    D. Challenges and How you fixed it:

    E. Additional Notes:
        Worked on developing a web application that proposes already existing software solution based on uploaded RFPs (Request for Proposal).
        Used ScraperWiki to crawl Civic Commons website and extract all software information.
        This is a part of the Code-for-America initiative.
        Won a GitHub Bronze award from Cloud-foundry organization.
Technologies and Languages used: Spring MVC, Python, ScraperWiki, HTML5, CSS3, JS, jQuery


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
7. Sentiment based review system
    A. Problem:
        - Evaluate individual features of a product instead of a overall product
        - Subjective nature of a user review

    B. How you solved it:
        - Extract FEATURES and find SENTIMENT for the features.
        1. Did PART OF SPEECH tagging on a sentence. 
            - This will tell the NOUNS and the ADJECTIVES
        2. Used APRIORI algorithm to extract features.
            http://nikhilvithlani.blogspot.com/2012/03/apriori-algorithm-for-data-mining-made.html
        3. Used SENTIMENT ANALYSIS to find about the feature
            - Identified the polarity to remove ambiguous sentiment values.
        - Used BIGRAMS to overcome words like "battery life"
        - Used a BAG of ADJECTIVES

    C. Interesting Stuffs:
        - From ANALYSIS found that running APRIORI on smaller data sets give precise results.

    D. Challenges and How you fixed it:
        - phrases like "blocks the lens"

    E. Additional Notes:
        - should use SVMs a better classifier.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. Instant Indoor Localization
    A. Problem:
        - When a stranger is inside a building they don't know their current position and the way out
        - WiFi is not available in ALL AREAS
        - GPS is useful only outdoor

    B. How you solved it:
        - Use Bluetooth + Accousitics + Accelerometer to find the current position on a floor map
        - Bluetooth find approximate position
        - Accoustics give if INDOOR or OUTDOOR
        - Accelerometer to find the behavior of a person
        - Compass is used to eliminate unreachable co-ordinates

    C. Interesting Stuffs:

    D. Challenges and How you fixed it:

    E. Additional Notes:

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5. Animats
    A. Problem:

    B. How you solved it:

    C. Interesting Stuffs:

    D. Challenges and How you fixed it:

    E. Additional Notes:
        Developed an animat learning environment where a cub learns hunting behavior from Lion.
        Single feed forward neural network is used to implement imitation and reinforcement learning.
        Made use of Java Repast library to creat the predator-prey scenrio in which the predator learns to hunt the prey.


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6. Haplotype
    A. Problem:

    B. How you solved it:

    C. Interesting Stuffs:

    D. Challenges and How you fixed it:

    E. Additional Notes:
        The Project aims to reassemble the haplotypes by linking the reads together.
        Align the reads to a reference genome to find out the SNP (Single Nucleotide Polymorphism) positions.
        Build a greedy algorithm for haplotype phasing from sequence reads, allowing for sequencing errors.


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
8. MIMO Antenna Power Allocation
    A. Problem:

    B. How you solved it:

    C. Interesting Stuffs:

    D. Challenges and How you fixed it:

    E. Additional Notes:

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
9. Directory Usage Statistics
    A. Problem:

    B. How you solved it:

    C. Interesting Stuffs:

    D. Challenges and How you fixed it:

    E. Additional Notes:

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10. Parallel Processing using Threads
    A. Problem:
        - Several image operations and parallel programming for performance improvement.

    B. How you solved it:
        - Used Open MP's to achieve parallel processing
        - #pragma directive to paralallize the for loops

        Scaling
        Rotation
            - Rotate by irregular angles was a challenge.
            - filled white spaces by averaging the colors
            - calculated new height of the image.

    C. Interesting Stuffs:

    D. Challenges and How you fixed it:

    E. Additional Notes:



--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
11. Final Paper - quorum based geo location service
    A. Problem:
       Efficient way to send data to nodes in a VSN.
       Eg: Sensors are deployed on the road to monitor road conditions.
           Information needs to be sent to any vehicle that would need the information

       3. Conditions for Geographic routing
          a. A node should know its location - Using GPS
          b. A node should know its negithbors - Beacon signals to one hop neighbors
          c. Source to know location of destination - This paper solves it

        Location Services:
            1. Flooding Based
               Any source in the network will be provided with the destination info
                a. Full network flooding
                b. Local network flooding

            2. Rendezvous Based
               Location Updates will be stored and Location queries will be looked up.
                a. Hash Based
                    - Overhead for building and maintaining the hash table
                    
                b. Quorum Based
                    - Destination sends Location update via N-S direction
                    - Source sends Location query via E-W direction

    B. How you solved it:
        Sensors are Source Nodes
        Emergency vehicle in Destination Node
        Imagine Sensors are deployed on the road.


        Say we have a Vehicle, 
        - it will register itself with the closest sensor.
        - The closest sensor will store the List of vehicles close by; This help to directly send
          a message to the vehicle
        - The closest sensor will SEND the PACKET (its own location and Vechicle info) in TWO
          OPPOSITE directions. One towards the center and another away from it.

        - One packet is sent to the Center Intersection Point - that we know already
        - Another packet is sent to the farthest node from CIP

        Location Query:
            - Sensor node that needs to send the info to a vehicle
            - It can find its position w.r.t CIP
            - Chooses a farthest node and sends LQ packets using Horizontal First Verical Next
            - Once LQ reaches the target, the target sensor sends the LQ back to Source
              using the same Horizontal First Vertical Next.
            - this create a Quadrangular path

        Location Reply:
            - LU is made between CIP and Network Boundary sensor
            - LQ is made by having CIP on the inside

    C. Interesting Stuffs:
        Moving Vehicle:
            - After LU, vehicle can move from the registered sensor
            Solution:
            - After moving register with the nearest sensor. Also tell the previous sensor
              with which it was registered.
            - The new sensor will take care of updating the previous sensor

    D. Challenges and How you fixed it:

    E. Additional Notes:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
VMware
Developed a model to estimate the space consumption of Virtual Machine images during VMotion.
Involved estimating the space savings due to Deduplication in the storage array.
Applied Bloom filters, hash comparison and sampling technique to compare our model with SDFS and LessFS volumes.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
EMC:

VDS:
    - Introduced in Win2K3
    DISKRAID:
        - View and Manage underlying physical disk in a LUN

    Why VDS:
        - Each company makes their own Storage Devices.
        - From any Windows Client we should be able to connect to the Storage Device

        - Used to manage LUNs
        - manage disks
        - manage end to end storage
